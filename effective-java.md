# Effective Java

-   第1章 引言
    -   编写清晰，正确，可用，健壮，灵活和可维护的代码
    -   以java 语言规范JLS准
-   第2章 创建和销毁对象
    -   关注对象的生命周期，合理生，合理死
    -   创建
        -   站在使用对象的客户端角度看，他们并不关心对象是如何创建出来的。因此创建可使用分离
            -   1 使用静态工厂方法替代构造器实现分离
                -   优点1：相比构造器统一的名称，静态工厂方法的名称使客户端直接知晓他获得了什么样的对象
                -   优点2：在工厂内部控制真正的对象创建，可以控制返回什么样的对象
                -   优点3：可按接口返回，适合基于接口的框架
                -   缺点1：
        -   不同类型的对象
            -   服务类，往往要求不管客户端怎样请求，都只能产生一个实例，即单例模式
                -   注意序列化反序列化时可能产生的问题
            -   工具类，不需要对象创建，全部都是静态方法，使用私有的构造方法禁止创建对象
            -   不可变类，有些类的对象个数有限的，比如字符串，布尔值，
            -   注意java中的自动装箱，在将基本类型转换为引用类型的时候，会自动调用new来创建实例，一旦在循环中自动装箱，将引起不必要的性能问题
            -   池类，一般小池可行，大池代码不易维护，增加内存占用，对象管理的技术赶不上JVM的技术
                -   Andorid中的Message.obtain就是一个静态工厂方法
            -   组件类，实体类这种可选参数很多，可使用Builder模式,提高客户端创建对象代码的简洁性
    -   销毁
        -   消除那些脱离业务生命周期的对象
            -   只要程序员自己管理业务对象的内存，就必须警惕
            -   注意缓存对象，在业务中使用weakrefere引用内存对象，当业务结束的时候，这些缓存会被自动回收；或者使用具体的缓存算法，比如LRU
            -   注意回调和监听器，服务端往往持有大量的客户端回调引用，当某个客户端业务结束的时候，会因为服务端存在的回调引用影响客户端对象的生命周期。这里也可以使用WeakReference
        -   避免使用Object.finalizer
            -   JVM不做保证
            -   扰乱JVM的内存调度
            -   可显示地编写终止方法来代替finalier,比如io流中的close
            -   ??也有可用的场景？？
            -   如果使用，必须使用super.finalize()形成终结方法链，确保父类终结方法的调用
            -   如果使用，可使用匿名内部类实现的卫兵来确保finalize被调用？？卫兵的finalize何时被调用|？？如果自己调用，那最多算一中补救
-   第3章 对于所有对象都通用的方法
    -   equals&hashCode
        -   按照等价关系的定义来处理。对象的自身定义（属性）决定了equals方法该如何实现，确保等价关系（自反性，对称性，传递性，一致性）的实现。比如Integer的equals是比较数字是否相等，
            -   使用==判断
            -   使用instanceof判断
            -   使用关键属性判读
            -   调整判断顺序，优化性能
            -   使用单元测试来保证
        -   覆盖equals时一定要覆盖hashcode：同一个对象必须有不同的hashcode，便于类似HashMap这样的数据结构类存储对象
            -   难点：确定一个较好的hash方法
    -   toString
        -   始终要覆盖toString:
            可以向外界传递对象的信息，在调试阶段，log分析中都很有用
    -   clone
    -   Comparable接口
-   第4章 类和接口
    -   使类和成员的可访问性最小化
        -   可认为是衡量一个模块封装程度的量化指标
        -   Rule1 尽可能地使每个类或者成员不被外界访问
            -   对于一个package下的类，最极端只有一个类是public的，其他都是default，为此类服务，此类为包外使用
            -   对于一个类下的成员，最极端的只有read
                -write,其他都是私有。这一条通常都较为熟悉
            -   为便于测试，可将测试类放置于同样的package结构中
            -   实例域，也就是属性成员，决不能是共有的。直接公开属性，意味着放弃了对这个属性权限的管理。
                -   一旦看到某个类违反了这条准则，应该立刻想到，这个类线程不安全
                -   使用final修饰，但必须是基本类型或者不可变应用，修饰一个数组或者可变引用，是没有意义的
    -   在公有类中使用访问方法而非公有域
        -   不要怕麻烦或繁琐，坚决使用set get
        -   包私有的，或者嵌套私有的，可以让步
    -   使可变性最小化
        -   不要提供任何会修改对象状态的方法
        -   保证类不会被扩展
            -   final修饰，不被继承
            -   私有或包级构造器，子类无法继承
        -   所有的域都是私有的
        -   确保对任何可变组件的互斥访问
        -   函数式编程模式，对不可变对象的操作返回一个另一个不可变对象，而不是去修改
    -   复合优先与继承
        -   继承适合在包内。包内往往是一组高内聚的类，因此使用继承可以增加内聚性
        -   继承破坏封装，增加了代码理解难度，需要仔细处理从父类继承而来的特性，因为一旦继承，特性将会被父类与子类同时修改，复杂程度大大升高
        -   父类和子类未来都会产生变化，这种变化可能会相互产生冲突
        -   使用组合可以避免上述情况
            -   装饰器模式
        -   A is a B的时候，A才能继承B
    -   要么为继承而设计，并提供文档说明，要么就禁止
