#include <cstring>
#include <memory>
#include <iostream>
#include <csignal>
#include <chrono>
#include <thread>
#include <respeaker.h>
#include <chain_nodes/pulse_collector_node.h>
#include <chain_nodes/vep_aec_bf_node.h>
#include <chain_nodes/vep_doa_kws_node.h>
extern "C"
{
#include <sndfile.h>
#include <unistd.h>
#include <getopt.h>
}
using namespace std;
using namespace respeaker;
#define BLOCK_SIZE_MS    8
static bool stop = false;
void SignalHandler(int signal){
  cerr << "Caught signal " << signal << ", terminating..." << endl;
  stop = true;
  //maintain the main thread untill the worker thread released its resource
  //std::this_thread::sleep_for(std::chrono::seconds(1));
}
static void help(const char *argv0) {
    cout << "main_vep_test [options]" << endl;
    cout << "A demo application for librespeaker." << endl << endl;
    cout << "  -h, --help                               Show this help" << endl;
    cout << "  -s, --source=SOURCE_NAME                 The source (microphone) to connect to" << endl;
}
int main(int argc, char *argv[]) {
    // Configures signal handling.
    struct sigaction sig_int_handler;
    sig_int_handler.sa_handler = SignalHandler;
    sigemptyset(&sig_int_handler.sa_mask);
    sig_int_handler.sa_flags = 0;
    sigaction(SIGINT, &sig_int_handler, NULL);
    sigaction(SIGTERM, &sig_int_handler, NULL);
    // parse opts
    int c;
    string source = "default";
    static const struct option long_options[] = {
        {"help",         0, NULL, 'h'},
        {"source",       1, NULL, 's'},
        {NULL,           0, NULL,  0}
    };
    while ((c = getopt_long(argc, argv, "s:h", long_options, NULL)) != -1) {
        switch (c) {
        case 'h' :
            help(argv[0]);
            return 0;
        case 's':
            source = string(optarg);
            break;
        default:
            return 0;
        }
    }
    unique_ptr<PulseCollectorNode> collector;
    unique_ptr<VepAecBeamformingNode> vep_bf;
    unique_ptr<VepDoaKwsNode> vep_kws;
    unique_ptr<ReSpeaker> respeaker;
    collector.reset(PulseCollectorNode::Create(source, 16000, BLOCK_SIZE_MS));
    vep_bf.reset(VepAecBeamformingNode::Create(6));
    vep_kws.reset(VepDoaKwsNode::Create(PROJECT_ROOT_DIR "/examples/C++/resources/common.res",
                                        PROJECT_ROOT_DIR "/examples/C++/resources/alexa.umdl",
                                        "0.5",
                                        10,
                                        true));
    vep_kws->DisableAutoStateTransfer();
    vep_kws->SetAgcTargetLevelDbfs(10);
    vep_bf->Uplink(collector.get());
    vep_kws->Uplink(vep_bf.get());
    respeaker.reset(ReSpeaker::Create());
    respeaker->RegisterChainByHead(collector.get());
    respeaker->RegisterOutputNode(vep_kws.get());
    if (!respeaker->Start(&stop)) {
        cout << "Can not start the respeaker node chain." << endl;
        return -1;
    }
    string data;
    int frames;
    size_t num_channels = respeaker->GetNumOutputChannels();
    int rate = respeaker->GetNumOutputRate();
    cout << "num channels: " << num_channels << ", rate: " << rate << endl;
    // init libsndfile
    SNDFILE *file ;
    SF_INFO sfinfo ;
    memset (&sfinfo, 0, sizeof (sfinfo));
    sfinfo.samplerate   = rate ;
    sfinfo.channels     = num_channels ;
    sfinfo.format       = (SF_FORMAT_WAV | SF_FORMAT_PCM_24) ;
    if (! (file = sf_open ("record_vep_test.wav", SFM_WRITE, &sfinfo)))
    {
        cout << "Error : Not able to open output file." << endl;
        return -1 ;
    }
    while (!stop)
    {
        data = respeaker->Listen();
        frames = data.length() / (sizeof(int16_t) * num_channels);
        sf_writef_short(file, (const int16_t *)(data.data()), frames);
        //cout << "." << flush;
    }
    cout << "stopping the respeaker worker thread..." << endl;
    respeaker->Stop();
    cout << "cleanup done." << endl;
    sf_close (file);
    cout << "wav file closed." << endl;
    return 0;
}
